# Reflection

## What are the key differences between unary, server streaming, and bi-directional streaming RPC (Remote Procedure Call) methods, and in what scenarios would each be most suitable?
Perbedaan utama antara ketiga jenis RPC ini terletak pada arah komunikasi dan jumlah pesan yang dipertukarkan dalam satu koneksi. Unary RPC digunakan ketika client mengirim satu permintaan dan menerima satu balasan, cocok untuk proses sederhana seperti login atau pengambilan data spesifik. Server streaming memungkinkan client mengirim satu permintaan dan menerima beberapa balasan secara bertahap dari server, ideal untuk kasus seperti notifikasi cuaca atau pembaruan harga saham. Sementara itu, bi-directional streaming memungkinkan pertukaran pesan dua arah secara simultan antara client dan server selama koneksi aktif, sangat sesuai untuk aplikasi real-time seperti percakapan daring atau aliran data langsung.

## What are the potential security considerations involved in implementing a gRPC service in Rust, particularly regarding authentication, authorization, and data encryption?
Keamanan menjadi hal yang krusial saat mengembangkan layanan gRPC dengan Rust, termasuk dalam hal autentikasi untuk memastikan identitas client, otorisasi untuk membatasi akses hanya kepada yang berhak, dan enkripsi data untuk menjaga kerahasiaan pertukaran data menggunakan TLS. Meskipun Rust menawarkan keunggulan dalam pengelolaan memori dan concurrency, pengembang tetap perlu cermat dalam mengatur sertifikat, token akses, serta mekanisme validasi untuk mencegah potensi celah keamanan.

## What are the potential challenges or issues that may arise when handling bidirectional streaming in Rust gRPC, especially in scenarios like chat applications?
Dalam implementasi bi-directional streaming menggunakan Rust, beberapa tantangan yang dapat muncul antara lain kondisi balapan (race condition), yaitu ketika dua pesan tiba hampir bersamaan dan mengganggu urutan pemrosesan. Sinkronisasi data juga menjadi tantangan untuk mencegah inkonsistensi. Selain itu, pengelolaan koneksi dan penggunaan sumber daya harus diperhatikan agar tidak menimbulkan memory leak atau deadlock. Meskipun Rust menyediakan alat bantu seperti tokio, mutex, dan sistem kepemilikan (ownership), desain program tetap harus dilakukan secara hati-hati.

## What are the advantages and disadvantages of using the tokio_stream::wrappers::ReceiverStream for streaming responses in Rust gRPC services?
ReceiverStream memudahkan proses konversi dari channel ke stream tanpa harus menangani proses streaming secara manual, mendukung model asynchronous modern di Rust. Kelebihannya adalah menyederhanakan pengelolaan aliran data dan meningkatkan keamanan sinkronisasi. Namun, kelemahannya adalah meningkatnya kompleksitas pemrograman async yang bisa membingungkan, khususnya bagi mereka yang belum terbiasa dengan pendekatan ini.

## In what ways could the Rust gRPC code be structured to facilitate code reuse and modularity, promoting maintainability and extensibility over time?
Untuk memastikan struktur kode yang rapi dan mudah diperluas, kode gRPC di Rust sebaiknya dibagi ke dalam modul atau direktori berdasarkan jenis RPC (unary, server streaming, bi-directional). Definisi layanan dapat ditempatkan di file .proto, sementara implementasinya dipisahkan dalam bentuk struct dan trait tersendiri. Dengan pendekatan modular seperti ini, kode akan lebih mudah dirawat, diuji, dan dikembangkan jika terjadi penambahan fitur atau perubahan sistem.

## In the MyPaymentService implementation, what additional steps might be necessary to handle more complex payment processing logic?
Untuk menangani logika pembayaran yang lebih kompleks, diperlukan pendekatan asynchronous atau pemrosesan multithread agar server dapat melayani banyak permintaan sekaligus tanpa hambatan. Selain itu, dibutuhkan sistem validasi transaksi yang ketat, mekanisme penanganan error yang andal, serta kemungkinan integrasi dengan message queue atau database eksternal untuk memastikan transaksi diproses dengan akurat dan efisien.

## What impact does the adoption of gRPC as a communication protocol have on the overall architecture and design of distributed systems, particularly in terms of interoperability with other technologies and platforms?
Adopsi gRPC memberikan pengaruh besar dalam perancangan sistem terdistribusi, terutama dalam hal interoperabilitas antar teknologi. Dengan menggunakan Protocol Buffers, layanan yang ditulis dalam bahasa pemrograman berbeda dapat saling berkomunikasi secara efisien tanpa membuat format data khusus. Selain itu, dukungan HTTP/2 memungkinkan koneksi yang ringan dan cepat antar layanan mikro (microservices), dengan tetap menjaga konsistensi struktur data.

## What are the advantages and disadvantages of using HTTP/2, the underlying protocol for gRPC, compared to HTTP/1.1 or HTTP/1.1 with WebSocket for REST APIs?
HTTP/2 memungkinkan koneksi yang lebih efisien dengan dukungan multiplexing, di mana banyak permintaan dan balasan dapat dikirim dalam satu koneksi tanpa harus menunggu satu sama lain. Ini membuatnya lebih cepat dibandingkan HTTP/1.1. Namun, implementasinya cenderung lebih kompleks dan rentan terhadap masalah jaringan karena semua komunikasi menggunakan satu koneksi. Sementara itu, WebSocket juga mendukung komunikasi dua arah seperti gRPC, tetapi tidak menawarkan struktur dan validasi data seketat gRPC dengan Protocol Buffers.

## How does the request-response model of REST APIs contrast with the bidirectional streaming capabilities of gRPC in terms of real-time communication and responsiveness?
Model request-response pada REST API bersifat satu arah dan memerlukan koneksi baru untuk setiap pertukaran data, sehingga kurang efisien untuk aplikasi real-time. Sebaliknya, gRPC mendukung streaming dua arah yang memungkinkan client dan server terus saling bertukar data dalam satu koneksi yang terus aktif. Ini meningkatkan kecepatan respon dan mengurangi overhead untuk aplikasi yang memerlukan komunikasi langsung secara real-time.

## What are the implications of the schema-based approach of gRPC, using Protocol Buffers, compared to the more flexible, schema-less nature of JSON in REST API payloads?
Pendekatan berbasis skema seperti Protocol Buffers di gRPC memastikan bahwa data yang dikirim sesuai dengan struktur yang telah didefinisikan, sehingga mengurangi risiko kesalahan dalam komunikasi antara client dan server. Di sisi lain, JSON yang tidak memiliki skema tetap lebih fleksibel dan mudah dibaca manusia, tetapi berpotensi menimbulkan masalah inkonsistensi jika tidak ada validasi yang ketat. Dengan skema Protobuf, pengembang memiliki kendali lebih terhadap validasi dan kompatibilitas sistem.
